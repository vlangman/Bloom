#pragma kernel ProcessNeurons

//emitters
#include "Emitters/periodicEmitter.hlsl"
//actions
#include "Actions/updateColourAction.hlsl"


AppendStructuredBuffer<uint> organismFiltered; //Filtered index
RWStructuredBuffer<Organism> organismBuffer; //has to be same name with rendering shader
RWStructuredBuffer<Neuron> neuronBuffer;

float _time;
float _deltaTime;
float4 _resolution;


Neuron ProcessNeuron(Neuron neuron){

	Neuron notMapped;
	
	if(EMITTER == neuron.baseType)
	{
		if(PERIODIC_EMITTER == neuron.type)
			return _periodicEmitter.Compute(neuron);
	}

	// if(ACTION == neuron.baseType)
	// {
	// 	 if(UPDATE_COLOUR_ACTION == neuron.type)
	// 		return _updateColourAction.Compute(neuron);
	// }


	return notMapped;
}



[numthreads(16,16,1)]
void ProcessNeurons (uint3 id : SV_DispatchThreadID)
{
	InitializeProgramState(_time,_deltaTime,_resolution);
	uint idx = id.y * _resolution.x + id.x;
	
	Organism organism =  organismBuffer[idx];
	uint start = organism.neuronsStartIndex;

	// iterate through all of the organisms neurons and compute any EMITTERS
	for(uint i = start; i < start + GlobalNeuronCount; i++)
	{
		Neuron neuron = neuronBuffer[i];
		if(EMITTER == neuron.baseType)
		{
			neuron = ProcessNeuron(neuron);
			organism.color = float4(neuron.value,0,0,1);
		}
		
		neuronBuffer[i] = neuron;
	}

	// float4 colour = float4(1,idx/(_resolution.x*_resolution.y),0,1);
	// organism.color = colour;

	//this is for testing when compiler errors suck comment me in and loop out
	// Neuron n = neuronBuffer[start];
	// ProcessNeuron(n);


	//RANDOM MOVE
	float seed = _time*_deltaTime;
	organism.orientation = float2(RandomNormalized(idx+seed), RandomNormalized(idx-seed ));
	// float2 nextMove = DegToVec(randomRange(idx,-360.0,360.0))*15.0;
	organism.position += organism.orientation*10*_deltaTime;

	//make update
	organismBuffer[idx] = organism;
	//only want the filtered ones
	organismFiltered.Append(idx);
}

