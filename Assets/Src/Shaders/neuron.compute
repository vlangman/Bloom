#pragma kernel ProcessNeurons

#include "globals.hlsl"
#include "Organisms/organism.hlsl"


#include "Neurons/neuronProcessor.hlsl"






AppendStructuredBuffer<uint> organismFiltered; //Filtered index
// AppendStructuredBuffer<INeuron> neuronLookupBuffer; //lookup for Compute Calls , just an empty buffer we will initialize on shader start from statics
RWStructuredBuffer<Organism> organismBuffer; //has to be same name with rendering shader
RWStructuredBuffer<Neuron> neuronBuffer;

float _time;
float _deltaTime;
float4 _resolution;


void ProcessOrganismNeurons(uint TYPE, inout Organism organism){
// iterate through all of the organisms neurons and compute any EMITTERS
	uint  index = organism.neuronsStartIndex;
	const uint maximum = index + GlobalNeuronCount;

	for(uint i = index; index < maximum; index++)
	{
		Neuron neuron = neuronBuffer[index];
		if(TYPE == neuron.baseType)
		{
			ProcessNeuron(neuron,organism);
		}
		neuronBuffer[index] = neuron;
		index++;
	}

}

[numthreads(32,32,1)]
void ProcessNeurons (uint3 id : SV_DispatchThreadID)
{
	UpdateProgramState(_time,_deltaTime,_resolution);

	uint idx = id.y * _resolution.x + id.x;	
	Organism organism = organismBuffer[idx];

	ProcessOrganismNeurons(EMITTER, organism);
	
	
	float4 colour = float4(1,idx/(_resolution.x*_resolution.y),0,1);
	organism.color = colour;

	//this is for testing when compiler errors suck comment me in and loop out
	// Neuron n = neuronBuffer[start];
	// ProcessNeuron(n);


	//RANDOM MOVE
	float seed = _time*_deltaTime;
	organism.orientation = float2(RandomNormalized(idx+seed), RandomNormalized(idx-seed ));
	float2 nextMove = DegToVec(RandomRange(idx,-360.0,360.0))*15.0;
	// organism.position += organism.orientation*10*_deltaTime;

	//make update
	organismBuffer[idx] = organism;
	//only want the filtered ones
	organismFiltered.Append(idx);
}

